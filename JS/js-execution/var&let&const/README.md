# 全局作用域、函数作用域、块级作用域

## 作用域
### 定义
程序中 **定义** 变量的区域，作用域控制了变量和函数的可见性和生命周期。
### ES6之前作用域
在`ES6`之前，`ES`的作用域只有两种： "全局作用域"和"函数作用域"
- 全局作用域
  - **全局作用域中的对象在代码的任何地方都可以访问，生命周期和页面生命周期同步。**
- 函数作用域
  - **指在函数内部定义的变量或者函数，只能在函数内部被访问。当函数执行结束后，函数内部定义的变量会随之销毁。**
    
## 变量提升的缺点
1. 变量容易在不被察觉的情况下被覆盖掉
```js
var fn = 'test';
function fn(){
    console.log('function')
}

console.log(fn);    // test
```
由于变量提升的原因，导致实际打印结果与预期不符，提升后的伪代码如下，所以最后会打印出`test`而不是`fn()`：
```js
var fn = undefined;
function fn(){}

fn = 'test';
console.log(fn);
```
2.该被销毁的变量没有被销毁掉

我们期望当`for`循环执行完毕后，`i`应该被销毁掉。 但是，实际上并没有销毁，而是因为变量提升的原因，在创建上下文阶段，`i`就已经被变量提升到`foo`的最顶端了。
```js
function foo(){
  for (var i = 0; i < 7; i++) {
  }
  console.log(i);   // 7
}
foo()
```

因为以上的一些缺点，所以`ES6`推出了块级作用域的概念。

## 块级作用域
### 定义
块级作用域指：使用一对大括号包裹的一段代码，如下：
```js
//if块
if(1){}

//while块
while(1){}

//函数块
function foo(){
 
//for循环块
for(let i = 0; i<100; i++){}

//单独一个块
{}
```
### let、const
#### 概述
为了解决变量提升带来的缺点，`ES6`引入了`let` `const`关键字来配合`{}`生成块级作用域。
```js
let x = 5
const y = 6
x = 7
y = 9 //报错，const声明的变量不可以修改
```
- 相同点：
  - 都可以生成块级作用域
  - 具有暂时性死区
  - 不可以重复声明
- 不同点：
  - `let`可以被重新赋值，`const`不可以被重新赋值
  - `const`必须有初始值  
    
### 分析代码
1.
```js
function varTest() {
  var x = 1;
  if (true) {
    var x = 2;  // 同样的变量!
    console.log(x);  // 2
  }
  console.log(x);  // 2
}
```
解释：由于`if`中使用`var`声明，所以内部`x`依旧会被提升到`varTest`顶部，导致变量被覆盖。
2.
```js
function letTest() {
  let x = 1;
  if (true) {
    let x = 2;  // 不同的变量
    console.log(x);  // 2
  }
  console.log(x);  // 1
}
```
解释：因为`let`关键字是支持块级作用域的。所以**在编译阶段，`JavaScript`引擎并不会把`if`块中通过`let`声明的变量存放到变量环境中，这也就意味着在`if`块通过`let`声明的关键字，并不会提升到全函数可见。** 所以在`if`块之内打印出来的值是`2`，跳出语块之后，打印出来的值就是`1`了。**块内使用`const/let`声明的变量不影响块外面的变量。**

### 从词法作用域分析js是如何支持块级作用域的
